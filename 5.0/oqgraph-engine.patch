Index: mysql-5.0.86/sql/oqgraph/COPYING
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ mysql-5.0.86/sql/oqgraph/COPYING	2009-11-03 21:36:59.000000000 -0800
@@ -0,0 +1,352 @@
+                      GNU GENERAL PUBLIC LICENSE
+                         Version 2, June 1991
+
+     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+
+     Everyone is permitted to copy and distribute verbatim copies
+     of this license document, but changing it is not allowed.
+
+Preamble
+========
+
+The licenses for most software are designed to take away your freedom
+to share and change it.  By contrast, the GNU General Public License is
+intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+When we speak of free software, we are referring to freedom, not price.
+Our General Public Licenses are designed to make sure that you have
+the freedom to distribute copies of free software (and charge for this
+service if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs; and that you know you can do these things.
+
+To protect your rights, we need to make restrictions that forbid anyone
+to deny you these rights or to ask you to surrender the rights.  These
+restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+For example, if you distribute copies of such a program, whether gratis
+or for a fee, you must give the recipients all the rights that you
+have.  You must make sure that they, too, receive or can get the source
+code.  And you must show them these terms so they know their rights.
+
+We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+Finally, any free program is threatened constantly by software patents.
+We wish to avoid the danger that redistributors of a free program will
+individually obtain patent licenses, in effect making the program
+proprietary.  To prevent this, we have made it clear that any patent
+must be licensed for everyone's free use or not licensed at all.
+
+The precise terms and conditions for copying, distribution and
+modification follow.
+
+                      GNU GENERAL PUBLIC LICENSE
+    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+  0. This License applies to any program or other work which contains a
+     notice placed by the copyright holder saying it may be distributed
+     under the terms of this General Public License.  The "Program",
+     below, refers to any such program or work, and a "work based on
+     the Program" means either the Program or any derivative work under
+     copyright law: that is to say, a work containing the Program or a
+     portion of it, either verbatim or with modifications and/or
+     translated into another language.  (Hereinafter, translation is
+     included without limitation in the term "modification".)  Each
+     licensee is addressed as "you".
+
+     Activities other than copying, distribution and modification are
+     not covered by this License; they are outside its scope.  The act
+     of running the Program is not restricted, and the output from the
+     Program is covered only if its contents constitute a work based on
+     the Program (independent of having been made by running the
+     Program).  Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+     source code as you receive it, in any medium, provided that you
+     conspicuously and appropriately publish on each copy an appropriate
+     copyright notice and disclaimer of warranty; keep intact all the
+     notices that refer to this License and to the absence of any
+     warranty; and give any other recipients of the Program a copy of
+     this License along with the Program.
+
+     You may charge a fee for the physical act of transferring a copy,
+     and you may at your option offer warranty protection in exchange
+     for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+     of it, thus forming a work based on the Program, and copy and
+     distribute such modifications or work under the terms of Section 1
+     above, provided that you also meet all of these conditions:
+
+       a. You must cause the modified files to carry prominent notices
+          stating that you changed the files and the date of any change.
+
+       b. You must cause any work that you distribute or publish, that
+          in whole or in part contains or is derived from the Program
+          or any part thereof, to be licensed as a whole at no charge
+          to all third parties under the terms of this License.
+
+       c. If the modified program normally reads commands interactively
+          when run, you must cause it, when started running for such
+          interactive use in the most ordinary way, to print or display
+          an announcement including an appropriate copyright notice and
+          a notice that there is no warranty (or else, saying that you
+          provide a warranty) and that users may redistribute the
+          program under these conditions, and telling the user how to
+          view a copy of this License.  (Exception: if the Program
+          itself is interactive but does not normally print such an
+          announcement, your work based on the Program is not required
+          to print an announcement.)
+
+     These requirements apply to the modified work as a whole.  If
+     identifiable sections of that work are not derived from the
+     Program, and can be reasonably considered independent and separate
+     works in themselves, then this License, and its terms, do not
+     apply to those sections when you distribute them as separate
+     works.  But when you distribute the same sections as part of a
+     whole which is a work based on the Program, the distribution of
+     the whole must be on the terms of this License, whose permissions
+     for other licensees extend to the entire whole, and thus to each
+     and every part regardless of who wrote it.
+
+     Thus, it is not the intent of this section to claim rights or
+     contest your rights to work written entirely by you; rather, the
+     intent is to exercise the right to control the distribution of
+     derivative or collective works based on the Program.
+
+     In addition, mere aggregation of another work not based on the
+     Program with the Program (or with a work based on the Program) on
+     a volume of a storage or distribution medium does not bring the
+     other work under the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+     under Section 2) in object code or executable form under the terms
+     of Sections 1 and 2 above provided that you also do one of the
+     following:
+
+       a. Accompany it with the complete corresponding machine-readable
+          source code, which must be distributed under the terms of
+          Sections 1 and 2 above on a medium customarily used for
+          software interchange; or,
+
+       b. Accompany it with a written offer, valid for at least three
+          years, to give any third-party, for a charge no more than your
+          cost of physically performing source distribution, a complete
+          machine-readable copy of the corresponding source code, to be
+          distributed under the terms of Sections 1 and 2 above on a
+          medium customarily used for software interchange; or,
+
+       c. Accompany it with the information you received as to the offer
+          to distribute corresponding source code.  (This alternative is
+          allowed only for noncommercial distribution and only if you
+          received the program in object code or executable form with
+          such an offer, in accord with Subsection b above.)
+
+     The source code for a work means the preferred form of the work for
+     making modifications to it.  For an executable work, complete
+     source code means all the source code for all modules it contains,
+     plus any associated interface definition files, plus the scripts
+     used to control compilation and installation of the executable.
+     However, as a special exception, the source code distributed need
+     not include anything that is normally distributed (in either
+     source or binary form) with the major components (compiler,
+     kernel, and so on) of the operating system on which the executable
+     runs, unless that component itself accompanies the executable.
+
+     If distribution of executable or object code is made by offering
+     access to copy from a designated place, then offering equivalent
+     access to copy the source code from the same place counts as
+     distribution of the source code, even though third parties are not
+     compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+     except as expressly provided under this License.  Any attempt
+     otherwise to copy, modify, sublicense or distribute the Program is
+     void, and will automatically terminate your rights under this
+     License.  However, parties who have received copies, or rights,
+     from you under this License will not have their licenses
+     terminated so long as such parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+     signed it.  However, nothing else grants you permission to modify
+     or distribute the Program or its derivative works.  These actions
+     are prohibited by law if you do not accept this License.
+     Therefore, by modifying or distributing the Program (or any work
+     based on the Program), you indicate your acceptance of this
+     License to do so, and all its terms and conditions for copying,
+     distributing or modifying the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+     Program), the recipient automatically receives a license from the
+     original licensor to copy, distribute or modify the Program
+     subject to these terms and conditions.  You may not impose any
+     further restrictions on the recipients' exercise of the rights
+     granted herein.  You are not responsible for enforcing compliance
+     by third parties to this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+     infringement or for any other reason (not limited to patent
+     issues), conditions are imposed on you (whether by court order,
+     agreement or otherwise) that contradict the conditions of this
+     License, they do not excuse you from the conditions of this
+     License.  If you cannot distribute so as to satisfy simultaneously
+     your obligations under this License and any other pertinent
+     obligations, then as a consequence you may not distribute the
+     Program at all.  For example, if a patent license would not permit
+     royalty-free redistribution of the Program by all those who
+     receive copies directly or indirectly through you, then the only
+     way you could satisfy both it and this License would be to refrain
+     entirely from distribution of the Program.
+
+     If any portion of this section is held invalid or unenforceable
+     under any particular circumstance, the balance of the section is
+     intended to apply and the section as a whole is intended to apply
+     in other circumstances.
+
+     It is not the purpose of this section to induce you to infringe any
+     patents or other property right claims or to contest validity of
+     any such claims; this section has the sole purpose of protecting
+     the integrity of the free software distribution system, which is
+     implemented by public license practices.  Many people have made
+     generous contributions to the wide range of software distributed
+     through that system in reliance on consistent application of that
+     system; it is up to the author/donor to decide if he or she is
+     willing to distribute software through any other system and a
+     licensee cannot impose that choice.
+
+     This section is intended to make thoroughly clear what is believed
+     to be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+     certain countries either by patents or by copyrighted interfaces,
+     the original copyright holder who places the Program under this
+     License may add an explicit geographical distribution limitation
+     excluding those countries, so that distribution is permitted only
+     in or among countries not thus excluded.  In such case, this
+     License incorporates the limitation as if written in the body of
+     this License.
+
+  9. The Free Software Foundation may publish revised and/or new
+     versions of the General Public License from time to time.  Such
+     new versions will be similar in spirit to the present version, but
+     may differ in detail to address new problems or concerns.
+
+     Each version is given a distinguishing version number.  If the
+     Program specifies a version number of this License which applies
+     to it and "any later version", you have the option of following
+     the terms and conditions either of that version or of any later
+     version published by the Free Software Foundation.  If the Program
+     does not specify a version number of this License, you may choose
+     any version ever published by the Free Software Foundation.
+
+ 10. If you wish to incorporate parts of the Program into other free
+     programs whose distribution conditions are different, write to the
+     author to ask for permission.  For software which is copyrighted
+     by the Free Software Foundation, write to the Free Software
+     Foundation; we sometimes make exceptions for this.  Our decision
+     will be guided by the two goals of preserving the free status of
+     all derivatives of our free software and of promoting the sharing
+     and reuse of software generally.
+
+                                NO WARRANTY
+ 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
+     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
+     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
+     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
+     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
+     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
+     SERVICING, REPAIR OR CORRECTION.
+
+ 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
+     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
+     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
+     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
+     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
+     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
+     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
+     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+                      END OF TERMS AND CONDITIONS
+How to Apply These Terms to Your New Programs
+=============================================
+
+If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these
+terms.
+
+To do so, attach the following notices to the program.  It is safest to
+attach them to the start of each source file to most effectively convey
+the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
+     Copyright (C) YYYY  NAME OF AUTHOR
+
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2 of the License, or
+     (at your option) any later version.
+
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     GNU General Public License for more details.
+
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
+     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+     This is free software, and you are welcome to redistribute it
+     under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the
+appropriate parts of the General Public License.  Of course, the
+commands you use may be called something other than `show w' and `show
+c'; they could even be mouse-clicks or menu items--whatever suits your
+program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+     `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+     SIGNATURE OF TY COON, 1 April 1989
+     Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library,
+you may consider it more useful to permit linking proprietary
+applications with the library.  If this is what you want to do, use the
+GNU Library General Public License instead of this License.
+
Index: mysql-5.0.86/sql/oqgraph/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ mysql-5.0.86/sql/oqgraph/Makefile.am	2009-11-03 21:36:59.000000000 -0800
@@ -0,0 +1,46 @@
+# Copyright (C) 2007-2009 Arjen G Lentz & Antony T Curtis for Open Query
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+# ======================================================================
+# Open Query Graph Computation Engine, based on a concept by Arjen Lentz
+# Mk.II implementation by Antony Curtis & Arjen Lentz
+# For more information, documentation, support, enhancement engineering,
+# and non-GPL licensing, see http://openquery.com/graph
+# or contact graph@openquery.com
+# For packaged binaries, see http://ourdelta.org
+# ======================================================================
+
+BOOST_CXXFLAGS =	-fexceptions -fimplicit-templates
+#BOOST_CXXFLAGS+=	-g
+BOOST_CXXFLAGS+=	-O3 -fomit-frame-pointer -fstrict-aliasing
+BOOST_CXXFLAGS+=	-momit-leaf-frame-pointer -falign-loops
+BOOST_CXXFLAGS+=	-fvisibility-inlines-hidden
+BOOST_CXXFLAGS+=	-funroll-loops -fno-trapping-math
+
+INCLUDES =
+DEFS =
+EXTRA_DIST =		graphcore.cc ha_oqgraph.cc ha_oqgraph.h
+noinst_HEADERS =	graphcore.h graphcore-types.h graphcore-graph.h
+
+if BUILD_OQGRAPHCORE
+
+noinst_LIBRARIES =	libgraphcore.a
+libgraphcore_a_SOURCES=	graphcore.cc
+
+graphcore.o: graphcore.cc $(HEADERS)
+	$(CXXCOMPILE) $(LM_CFLAGS) $(BOOST_CXXFLAGS) -c graphcore.cc
+
+endif
Index: mysql-5.0.86/sql/oqgraph/README
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ mysql-5.0.86/sql/oqgraph/README	2009-11-03 21:36:59.000000000 -0800
@@ -0,0 +1,15 @@
+======================================================================
+Open Query Graph Computation Engine, based on a concept by Arjen Lentz
+Copyright (C) 2007-2009 Arjen G Lentz & Antony T Curtis for Open Query
+Mk.II implementation by Antony Curtis & Arjen Lentz
+
+- Open Query original code licensed under GPLv2+
+- MySQL derived glue code licensed under GPLv2
+- Boost library licensed under Boost Software License (GPL compatible)
+
+For more information, documentation, support, enhancement engineering,
+and non-GPL licensing, see http://openquery.com/graph
+or contact graph@openquery.com
+
+For packaged binaries, see http://ourdelta.org
+======================================================================
Index: mysql-5.0.86/sql/oqgraph/graphcore-graph.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ mysql-5.0.86/sql/oqgraph/graphcore-graph.h	2009-11-03 21:36:59.000000000 -0800
@@ -0,0 +1,56 @@
+/* Copyright (C) 2007-2009 Arjen G Lentz & Antony T Curtis for Open Query
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/* ======================================================================
+   Open Query Graph Computation Engine, based on a concept by Arjen Lentz
+   Mk.II implementation by Antony Curtis & Arjen Lentz
+   For more information, documentation, support, enhancement engineering,
+   and non-GPL licensing, see http://openquery.com/graph
+   or contact graph@openquery.com
+   For packaged binaries, see http://ourdelta.org
+   ======================================================================
+*/
+
+#ifndef oq_graphcore_graph_h_
+#define oq_graphcore_graph_h_
+
+typedef struct {
+  VertexID id;
+} VertexInfo;
+
+typedef struct {
+  EdgeWeight weight;
+} EdgeInfo;
+
+typedef adjacency_list
+<
+  vecS,
+  vecS,
+  bidirectionalS,
+  VertexInfo,
+  EdgeInfo
+> Graph;
+
+#define GRAPH_WEIGHTMAP(G) get(&EdgeInfo::weight, G)
+typedef property_map<Graph, EdgeWeight EdgeInfo::*>::type weightmap_type;
+
+#define GRAPH_INDEXMAP(G)  get(vertex_index, G)
+typedef property_map<Graph, vertex_index_t>::type indexmap_type;
+
+#define GRAPH_IDMAP(G)     get(&VertexInfo::id, G)
+typedef property_map<Graph, VertexID VertexInfo::*>::type idmap_type;
+
+#endif
Index: mysql-5.0.86/sql/oqgraph/graphcore-types.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ mysql-5.0.86/sql/oqgraph/graphcore-types.h	2009-11-03 21:36:59.000000000 -0800
@@ -0,0 +1,36 @@
+/* Copyright (C) 2007-2009 Arjen G Lentz & Antony T Curtis for Open Query
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/* ======================================================================
+   Open Query Graph Computation Engine, based on a concept by Arjen Lentz
+   Mk.II implementation by Antony Curtis & Arjen Lentz
+   For more information, documentation, support, enhancement engineering,
+   and non-GPL licensing, see http://openquery.com/graph
+   or contact graph@openquery.com
+   For packaged binaries, see http://ourdelta.org
+   ======================================================================
+*/
+
+#ifndef oq_graphcore_types_h_
+#define oq_graphcore_types_h_
+namespace open_query
+{
+
+  typedef unsigned long long VertexID;
+  typedef double EdgeWeight;
+
+}
+#endif
Index: mysql-5.0.86/sql/oqgraph/graphcore.cc
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ mysql-5.0.86/sql/oqgraph/graphcore.cc	2009-11-03 22:05:22.000000000 -0800
@@ -0,0 +1,1035 @@
+/* Copyright (C) 2007-2009 Arjen G Lentz & Antony T Curtis for Open Query
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/* ======================================================================
+   Open Query Graph Computation Engine, based on a concept by Arjen Lentz
+   Mk.II implementation by Antony Curtis & Arjen Lentz
+   For more information, documentation, support, enhancement engineering,
+   and non-GPL licensing, see http://openquery.com/graph
+   or contact graph@openquery.com
+   For packaged binaries, see http://ourdelta.org
+   ======================================================================
+*/
+
+#include <strings.h>
+
+#define BOOST_ALL_NO_LIB 1
+
+#include <boost/config.hpp>
+
+#include <set>
+#include <stack>
+
+#include <boost/property_map.hpp>
+
+#include <boost/graph/graph_concepts.hpp>
+#include <boost/graph/graph_archetypes.hpp>
+#include <boost/graph/adjacency_list.hpp>
+#include <boost/graph/breadth_first_search.hpp>
+#include <boost/graph/dijkstra_shortest_paths.hpp>
+#include <boost/graph/iteration_macros.hpp>
+#include <boost/graph/reverse_graph.hpp>
+#include <boost/graph/graph_utility.hpp>
+
+#include "graphcore.h"
+
+using namespace open_query;
+using namespace boost;
+
+enum vertex_id_t { vertex_id };
+
+static const row empty_row = { 0 };
+
+namespace boost
+{
+  BOOST_INSTALL_PROPERTY(vertex, id);
+}
+
+namespace open_query {
+
+  #include "graphcore-graph.h"
+
+  typedef graph_traits<Graph>::vertex_descriptor Vertex;
+  typedef graph_traits<Graph>::edge_descriptor Edge;
+
+  typedef std::list<std::pair<Vertex,optional<EdgeWeight> > > shortest_path_list;
+  typedef shortest_path_list::iterator shortest_path_iterator;
+
+  template<typename ID, typename IDMap>
+  class id_equals_t
+  {
+  public:
+    id_equals_t(ID id, IDMap map)
+      : m_id(id), m_map(map)
+    { }
+    template<typename V>
+    bool operator()(V u) const
+    {
+      return m_map[u] == m_id;
+    }
+  private:
+    ID m_id;
+    IDMap m_map;
+  };
+
+  template<typename ID, typename IDMap>
+  inline id_equals_t<ID,IDMap>
+  id_equals(ID id, IDMap idmap)
+  {
+    return id_equals_t<ID,IDMap>(id, idmap);
+  }
+
+  template<typename T, typename Graph>
+  class target_equals_t
+  {
+  public:
+    target_equals_t(T target, Graph &g)
+      : m_target(target), m_g(g)
+    { }
+    template<typename V>
+    bool operator()(V u) const
+    {
+      return target(u, m_g) == m_target;
+    }
+  private:
+    T m_target;
+    Graph &m_g;
+  };
+
+  template<typename T, typename Graph>
+  inline target_equals_t<T,Graph>
+  target_equals(T target, Graph &g)
+  {
+    return target_equals_t<T,Graph>(target, g);
+  }
+
+  template<typename T, typename Graph>
+  class source_equals_t
+  {
+  public:
+    source_equals_t(T source, Graph &g)
+      : m_source(source), m_g(g)
+    { }
+    template<typename V>
+    bool operator()(V u) const
+    {
+      return source(u, m_g) == m_source;
+    }
+  private:
+    T m_source;
+    Graph &m_g;
+  };
+
+  template<typename T, typename Graph>
+  inline source_equals_t<T,Graph>
+  source_equals(T source, Graph &g)
+  {
+    return source_equals_t<T,Graph>(source, g);
+  }
+
+  struct reference
+  {
+    int m_flags;
+    int m_sequence;
+    Vertex m_vertex;
+    Edge m_edge;
+    EdgeWeight m_weight;
+
+    enum
+    {
+      HAVE_SEQUENCE = 1,
+      HAVE_WEIGHT = 2,
+      HAVE_EDGE = 4,
+    };
+
+    inline reference()
+      : m_flags(0), m_sequence(0),
+        m_vertex(graph_traits<Graph>::null_vertex()),
+        m_edge(), m_weight(0)
+    { }
+
+    inline reference(int s, Edge e)
+      : m_flags(HAVE_SEQUENCE | HAVE_EDGE), m_sequence(s),
+        m_vertex(graph_traits<Graph>::null_vertex()),
+        m_edge(e), m_weight(0)
+    { }
+
+    inline reference(int s, Vertex v, const optional<Edge> &e,
+                     const optional<EdgeWeight> &w)
+      : m_flags(HAVE_SEQUENCE | (w ? HAVE_WEIGHT : 0) | (e ? HAVE_EDGE : 0)),
+        m_sequence(s), m_vertex(v)
+    {
+      if (w) m_weight= *w;
+      if (e) m_edge= *e;
+    }
+
+    inline reference(int s, Vertex v, Edge e, EdgeWeight w)
+      : m_flags(HAVE_SEQUENCE | HAVE_WEIGHT | HAVE_EDGE),
+        m_sequence(s), m_vertex(v), m_edge(e), m_weight(w)
+    { }
+
+    inline reference(int s, Vertex v, EdgeWeight w)
+      : m_flags(HAVE_SEQUENCE | HAVE_WEIGHT),
+        m_sequence(s), m_vertex(v), m_edge(), m_weight(w)
+    { }
+
+    inline reference(int s, Vertex v)
+      : m_flags(HAVE_SEQUENCE), m_sequence(s), m_vertex(v), m_edge(),
+        m_weight(0)
+    { }
+
+    optional<int> sequence() const
+    {
+      if (m_flags & HAVE_SEQUENCE)
+      {
+        return m_sequence;
+      }
+      return optional<int>();
+    }
+
+    optional<Vertex> vertex() const
+    {
+      if (m_vertex != graph_traits<Graph>::null_vertex())
+        return m_vertex;
+      return optional<Vertex>();
+    }
+
+    optional<Edge> edge() const
+    {
+      if (m_flags & HAVE_EDGE)
+        return m_edge;
+      return optional<Edge>();
+    };
+
+    optional<EdgeWeight> weight() const
+    {
+      if (m_flags & HAVE_WEIGHT)
+        return m_weight;
+      return optional<EdgeWeight>();
+    }
+  };
+}
+
+namespace open_query {
+  class GRAPHCORE_INTERNAL oqgraph_share
+  {
+  public:
+    Graph g;
+
+    weightmap_type weightmap;
+    idmap_type idmap;
+    indexmap_type indexmap;
+
+    optional<Vertex> find_vertex(VertexID id) const;
+    optional<Edge> find_edge(Vertex, Vertex) const;
+
+    inline oqgraph_share() throw()
+      : g(),
+        weightmap(GRAPH_WEIGHTMAP(g)),
+        idmap(GRAPH_IDMAP(g)),
+        indexmap(GRAPH_INDEXMAP(g))
+    { }
+    inline ~oqgraph_share()
+    { }
+  };
+
+  class GRAPHCORE_INTERNAL oqgraph_cursor
+  {
+  public:
+    oqgraph_share *const share;
+
+    inline oqgraph_cursor(oqgraph_share *arg)
+      : share(arg)
+    { }
+    virtual ~oqgraph_cursor()
+    { }
+
+    virtual int fetch_row(const row &, row&) = 0;
+    virtual int fetch_row(const row &, row&, const reference&) = 0;
+    virtual void current(reference& ref) const = 0;
+  };
+}
+
+namespace open_query {
+  class GRAPHCORE_INTERNAL stack_cursor : public oqgraph_cursor
+  {
+  private:
+    optional<EdgeWeight> no_weight;
+  public:
+    int sequence;
+    std::stack<reference> results;
+    reference last;
+
+    inline stack_cursor(oqgraph_share *arg)
+      : oqgraph_cursor(arg), no_weight(), sequence(0), results(), last()
+    { }
+
+    int fetch_row(const row &, row&);
+    int fetch_row(const row &, row&, const reference&);
+
+    void current(reference& ref) const
+    {
+      ref= last;
+    }
+  };
+
+  class GRAPHCORE_INTERNAL vertices_cursor : public oqgraph_cursor
+  {
+    typedef graph_traits<Graph>::vertex_iterator vertex_iterator;
+
+    size_t position;
+    reference last;
+  public:
+    inline vertices_cursor(oqgraph_share *arg)
+      : oqgraph_cursor(arg), position(0)
+    { }
+
+    int fetch_row(const row &, row&);
+    int fetch_row(const row &, row&, const reference&);
+
+    void current(reference& ref) const
+    {
+      ref= last;
+    }
+
+  };
+
+  class GRAPHCORE_INTERNAL edges_cursor : public oqgraph_cursor
+  {
+    typedef graph_traits<Graph>::edge_iterator edge_iterator;
+    typedef edge_iterator::difference_type edge_difference;
+
+    edge_difference position;
+    reference last;
+  public:
+    inline edges_cursor(oqgraph_share *arg)
+      : oqgraph_cursor(arg), position(0), last()
+    { }
+
+    int fetch_row(const row &, row&);
+    int fetch_row(const row &, row&, const reference&);
+
+    void current(reference& ref) const
+    {
+      ref= last;
+    }
+  };
+
+  struct GRAPHCORE_INTERNAL oqgraph_visit_dist
+    : public base_visitor<oqgraph_visit_dist>
+  {
+    typedef on_finish_vertex event_filter;
+
+    oqgraph_visit_dist(std::vector<Vertex>::iterator p,
+                       std::vector<EdgeWeight>::iterator d,
+                       stack_cursor *cursor)
+      : seq(0), m_cursor(*cursor), m_p(p), m_d(d)
+    { assert(cursor); }
+
+    template<class T, class Graph>
+    void operator()(T u, Graph &g)
+    {
+      m_cursor.results.push(reference(++seq, u, m_d[GRAPH_INDEXMAP(g)[u]]));
+    }
+  private:
+    int seq;
+    stack_cursor &m_cursor;
+    std::vector<Vertex>::iterator m_p;
+    std::vector<EdgeWeight>::iterator m_d;
+  };
+
+  template<bool record_weight, typename goal_filter>
+  struct GRAPHCORE_INTERNAL oqgraph_goal
+    : public base_visitor<oqgraph_goal<record_weight,goal_filter> >
+  {
+    typedef goal_filter event_filter;
+
+    oqgraph_goal(Vertex goal, std::vector<Vertex>::iterator p,
+                 stack_cursor *cursor)
+      : m_goal(goal), m_cursor(*cursor), m_p(p)
+    { assert(cursor); }
+
+    template<class T, class Graph>
+    void operator()(T u, Graph &g)
+    {
+      if (u == m_goal)
+      {
+        int seq= 0;
+        indexmap_type indexmap= GRAPH_INDEXMAP(g);
+
+        for (Vertex q, v= u;; v = q, seq++)
+          if ((q= m_p[ indexmap[v] ]) == v)
+            break;
+
+        for (Vertex v= u;; u= v)
+        {
+          optional<Edge> edge;
+          optional<EdgeWeight> weight;
+          v= m_p[ indexmap[u] ];
+          if (record_weight && u != v)
+          {
+            typename graph_traits<Graph>::out_edge_iterator ei, ei_end;
+            for (tie(ei, ei_end)= out_edges(v, g); ei != ei_end; ++ei)
+            {
+              if (target(*ei, g) == u)
+              {
+                edge= *ei;
+                weight= GRAPH_WEIGHTMAP(g)[*ei];
+                break;
+              }
+            }
+          }
+          else if (u != v)
+            weight= 1;
+          m_cursor.results.push(reference(seq--, u, edge, weight));
+          if (u == v)
+            break;
+        }
+        throw this;
+      }
+    }
+
+  private:
+    Vertex m_goal;
+    stack_cursor &m_cursor;
+    std::vector<Vertex>::iterator m_p;
+  };
+}
+
+namespace open_query
+{
+  inline oqgraph::oqgraph(oqgraph_share *arg) throw()
+    : share(arg), cursor(0)
+  { }
+
+  inline oqgraph::~oqgraph() throw()
+  {
+    delete cursor;
+  }
+
+  unsigned oqgraph::edges_count() const throw()
+  {
+    return num_edges(share->g);
+  }
+
+  unsigned oqgraph::vertices_count() const throw()
+  {
+    return num_vertices(share->g);
+  }
+
+  oqgraph* oqgraph::create(oqgraph_share *share) throw()
+  {
+    assert(share != NULL);
+    return new (std::nothrow) oqgraph(share);
+  }
+
+  oqgraph_share* oqgraph::create() throw()
+  {
+    return new (std::nothrow) oqgraph_share();
+  }
+
+  optional<Edge>
+  oqgraph_share::find_edge(Vertex orig, Vertex dest) const
+  {
+    if (in_degree(dest, g) >= out_degree(orig, g))
+    {
+      graph_traits<Graph>::out_edge_iterator ei, ei_end;
+      tie(ei, ei_end)= out_edges(orig, g);
+      if ((ei= find_if(ei, ei_end, target_equals(dest, g))) != ei_end)
+        return *ei;
+    }
+    else
+    {
+      graph_traits<Graph>::in_edge_iterator ei, ei_end;
+      tie(ei, ei_end)= in_edges(dest, g);
+      if ((ei= find_if(ei, ei_end, source_equals(orig, g))) != ei_end)
+        return *ei;
+    }
+    return optional<Edge>();
+  }
+
+  optional<Vertex>
+  oqgraph_share::find_vertex(VertexID id) const
+  {
+    optional<Vertex> result;
+    graph_traits<Graph>::vertex_iterator vi, viend;
+
+    tie(vi, viend)= vertices(g);
+    if ((vi= std::find_if(vi, viend, id_equals(id, idmap))) != viend)
+      result= *vi;
+    return result;
+  }
+
+  int oqgraph::delete_all() throw()
+  {
+    share->g.clear();
+    return 0;
+  }
+
+  int oqgraph::insert_edge(
+      VertexID orig_id, VertexID dest_id, EdgeWeight weight, bool replace) throw()
+  {
+    optional<Vertex> orig, dest;
+    optional<Edge> edge;
+    bool inserted= 0;
+
+    if (weight < 0)
+      return INVALID_WEIGHT;
+    if (!(orig= share->find_vertex(orig_id)))
+    {
+      orig= add_vertex(share->g);
+      if (orig == graph_traits<Graph>::null_vertex())
+        return CANNOT_ADD_VERTEX;
+      share->idmap[*orig]= orig_id;
+    }
+    if (!(dest= share->find_vertex(dest_id)))
+    {
+      dest= add_vertex(share->g);
+      if (dest == graph_traits<Graph>::null_vertex())
+        return CANNOT_ADD_VERTEX;
+      share->idmap[*dest]= dest_id;
+    }
+    if (!(edge= share->find_edge(*orig, *dest)))
+    {
+      tie(edge, inserted)= add_edge(*orig, *dest, share->g);
+      if (!inserted)
+        return CANNOT_ADD_EDGE;
+    }
+    else
+    {
+      if (!replace)
+        return DUPLICATE_EDGE;
+    }
+    share->weightmap[*edge]= weight;
+    return OK;
+  }
+
+  int oqgraph::delete_edge(current_row_st) throw()
+  {
+    reference ref;
+    if (cursor)
+      return EDGE_NOT_FOUND;
+    cursor->current(ref);
+    optional<Edge> edge;
+    if (!(edge= ref.edge()))
+      return EDGE_NOT_FOUND;
+    Vertex orig= source(*edge, share->g);
+    Vertex dest= target(*edge, share->g);
+    remove_edge(*edge, share->g);
+    if (!degree(orig, share->g))
+      remove_vertex(orig, share->g);
+    if (!degree(dest, share->g))
+      remove_vertex(dest, share->g);
+    return OK;
+  }
+
+  int oqgraph::modify_edge(current_row_st,
+      VertexID *orig_id, VertexID *dest_id, EdgeWeight *weight,
+      bool replace) throw()
+  {
+    if (!cursor)
+      return EDGE_NOT_FOUND;
+    reference ref;
+    cursor->current(ref);
+    optional<Edge> edge;
+    if (!(edge= ref.edge()))
+      return EDGE_NOT_FOUND;
+    if (weight && *weight < 0)
+      return INVALID_WEIGHT;
+
+    optional<Vertex> orig= source(*edge, share->g),
+                     dest= target(*edge, share->g);
+
+    bool orig_neq= orig_id ? share->idmap[*orig] != *orig_id : 0;
+    bool dest_neq= dest_id ? share->idmap[*dest] != *dest_id : 0;
+    if (orig_neq || dest_neq)
+    {
+      optional<Edge> new_edge;
+      if (orig_neq && !(orig= share->find_vertex(*orig_id)))
+      {
+        orig= add_vertex(share->g);
+        if (orig == graph_traits<Graph>::null_vertex())
+          return CANNOT_ADD_VERTEX;
+        share->idmap[*orig]= *orig_id;
+      }
+      if (dest_neq && !(dest= share->find_vertex(*dest_id)))
+      {
+        dest= add_vertex(share->g);
+        if (dest == graph_traits<Graph>::null_vertex())
+          return CANNOT_ADD_VERTEX;
+        share->idmap[*dest]= *dest_id;
+      }
+      if (!(new_edge= share->find_edge(*orig, *dest)))
+      {
+        bool inserted;
+        tie(new_edge, inserted)= add_edge(*orig, *dest, share->g);
+        if (!inserted)
+          return CANNOT_ADD_EDGE;
+      }
+      else
+      {
+        if (!replace)
+          return DUPLICATE_EDGE;
+      }
+      share->weightmap[*new_edge]= share->weightmap[*edge];
+      remove_edge(*edge, share->g);
+      edge= new_edge;
+    }
+    if (weight)
+      share->weightmap[*edge]= *weight;
+    return OK;
+  }
+
+  int oqgraph::modify_edge(
+      VertexID orig_id, VertexID dest_id, EdgeWeight weight) throw()
+  {
+    optional<Vertex> orig, dest;
+    optional<Edge> edge;
+
+    if (weight < 0)
+      return INVALID_WEIGHT;
+    if (!(orig= share->find_vertex(orig_id)))
+      return EDGE_NOT_FOUND;
+    if (!(dest= share->find_vertex(dest_id)))
+      return EDGE_NOT_FOUND;
+    if (!(edge= share->find_edge(*orig, *dest)))
+      return EDGE_NOT_FOUND;
+    share->weightmap[*edge]= weight;
+    return OK;
+  }
+
+
+  int oqgraph::delete_edge(VertexID orig_id, VertexID dest_id) throw()
+  {
+    optional<Vertex> orig, dest;
+    optional<Edge> edge;
+
+    if (!(orig= share->find_vertex(orig_id)))
+      return EDGE_NOT_FOUND;
+    if (!(dest= share->find_vertex(dest_id)))
+      return EDGE_NOT_FOUND;
+    if (!(edge= share->find_edge(*orig, *dest)))
+      return EDGE_NOT_FOUND;
+    remove_edge(*edge, share->g);
+    if (!degree(*orig, share->g))
+      remove_vertex(*orig, share->g);
+    if (!degree(*dest, share->g))
+      remove_vertex(*dest, share->g);
+    return OK;
+  }
+
+
+  int oqgraph::search(int *latch, VertexID *orig_id, VertexID *dest_id) throw()
+  {
+      optional<Vertex> orig, dest;
+      int op= 0, seq= 0;
+      enum {
+        NO_SEARCH = 0,
+        DIJKSTRAS = 1,
+        BREADTH_FIRST = 2,
+
+	ALGORITHM = 0x0ffff,
+        HAVE_ORIG = 0x10000,
+        HAVE_DEST = 0x20000,
+      };
+
+      delete cursor; cursor= 0;
+      row_info= empty_row;
+      if ((row_info.latch_indicator= latch))
+        op= ALGORITHM & (row_info.latch= *latch);
+      if ((row_info.orig_indicator= orig_id) && (op|= HAVE_ORIG))
+        orig= share->find_vertex((row_info.orig= *orig_id));
+      if ((row_info.dest_indicator= dest_id) && (op|= HAVE_DEST))
+        dest= share->find_vertex((row_info.dest= *dest_id));
+    //try
+    //{
+      switch (op)
+      {
+      case NO_SEARCH | HAVE_ORIG | HAVE_DEST:
+      case NO_SEARCH | HAVE_ORIG:
+        if ((cursor= new (std::nothrow) stack_cursor(share)) && orig)
+        {
+          graph_traits<Graph>::out_edge_iterator ei, ei_end;
+          for (tie(ei, ei_end)= out_edges(*orig, share->g); ei != ei_end; ++ei)
+          {
+            Vertex v= target(*ei, share->g);
+            static_cast<stack_cursor*>(cursor)->
+                results.push(reference(++seq, v, *ei, share->weightmap[*ei]));
+          }
+        }
+        /* fall through */
+      case NO_SEARCH | HAVE_DEST:
+        if ((op & HAVE_DEST) &&
+            (cursor || (cursor= new (std::nothrow) stack_cursor(share))) &&
+	    dest)
+        {
+          graph_traits<Graph>::in_edge_iterator ei, ei_end;
+          for (tie(ei, ei_end)= in_edges(*dest, share->g); ei != ei_end; ++ei)
+          {
+            Vertex v= source(*ei, share->g);
+            static_cast<stack_cursor*>(cursor)->
+                results.push(reference(++seq, v, *ei, share->weightmap[*ei]));
+          }
+        }
+        break;
+
+      case NO_SEARCH:
+        cursor= new (std::nothrow) vertices_cursor(share);
+        break;
+
+      case DIJKSTRAS | HAVE_ORIG | HAVE_DEST:
+        if ((cursor= new (std::nothrow) stack_cursor(share)) && orig && dest)
+        {
+          std::vector<Vertex> p(num_vertices(share->g));
+          std::vector<EdgeWeight> d(num_vertices(share->g));
+          oqgraph_goal<true, on_finish_vertex>
+              vis(*dest, p.begin(), static_cast<stack_cursor*>(cursor));
+          p[share->indexmap[*orig]]= *orig;
+          try
+          {
+            dijkstra_shortest_paths(share->g, *orig,
+                weight_map(
+                  share->weightmap
+                ).
+                distance_map(
+                    make_iterator_property_map(d.begin(), share->indexmap)
+                ).
+                predecessor_map(
+                    make_iterator_property_map(p.begin(), share->indexmap)
+                ).
+                visitor(
+                    make_dijkstra_visitor(vis)
+                )
+            );
+          }
+          catch (...)
+          { /* printf("found\n"); */ }
+        }
+        break;
+
+      case BREADTH_FIRST | HAVE_ORIG | HAVE_DEST:
+        if ((cursor= new (std::nothrow) stack_cursor(share)) && orig && dest)
+        {
+          std::vector<Vertex> p(num_vertices(share->g));
+          oqgraph_goal<false, on_discover_vertex>
+              vis(*dest, p.begin(), static_cast<stack_cursor*>(cursor));
+          p[share->indexmap[*orig]]= *orig;
+          try
+          {
+            breadth_first_search(share->g, *orig,
+                visitor(make_bfs_visitor(
+                    std::make_pair(
+                        record_predecessors(
+                            make_iterator_property_map(p.begin(), share->indexmap),
+                            on_tree_edge()
+                        ),
+                        vis)
+                    )
+                )
+            );
+          }
+          catch (...)
+          { /* printf("found\n"); */ }
+        }
+        break;
+
+      case DIJKSTRAS | HAVE_ORIG:
+      case BREADTH_FIRST | HAVE_ORIG:
+        if ((cursor= new (std::nothrow) stack_cursor(share)) && (orig || dest))
+        {
+          std::vector<Vertex> p(num_vertices(share->g));
+          std::vector<EdgeWeight> d(num_vertices(share->g));
+          oqgraph_visit_dist vis(p.begin(), d.begin(),
+                                 static_cast<stack_cursor*>(cursor));
+          p[share->indexmap[*orig]]= *orig;
+          switch (ALGORITHM & op)
+          {
+          case DIJKSTRAS:
+            dijkstra_shortest_paths(share->g, *orig,
+                weight_map(
+                  share->weightmap
+                ).
+                distance_map(
+                    make_iterator_property_map(d.begin(), share->indexmap)
+                ).
+                predecessor_map(
+                    make_iterator_property_map(p.begin(), share->indexmap)
+                ).
+                visitor(
+                    make_dijkstra_visitor(vis)
+                )
+            );
+            break;
+          case BREADTH_FIRST:
+            breadth_first_search(share->g, *orig,
+                visitor(make_bfs_visitor(
+                    std::make_pair(
+                        record_predecessors(
+                            make_iterator_property_map(p.begin(),
+                                                       share->indexmap),
+                            on_tree_edge()
+                        ),
+                    std::make_pair(
+                        record_distances(
+                            make_iterator_property_map(d.begin(),
+                                                       share->indexmap),
+                            on_tree_edge()
+                        ),
+                        vis
+                    ))
+                ))
+            );
+            break;
+          default:
+            abort();
+          }
+        }
+        break;
+
+      case BREADTH_FIRST | HAVE_DEST:
+      case DIJKSTRAS | HAVE_DEST:
+        if ((cursor= new (std::nothrow) stack_cursor(share)) && (orig || dest))
+        {
+          std::vector<Vertex> p(num_vertices(share->g));
+          std::vector<EdgeWeight> d(num_vertices(share->g));
+          oqgraph_visit_dist vis(p.begin(), d.begin(),
+                                 static_cast<stack_cursor*>(cursor));
+          reverse_graph<Graph> r(share->g);
+          p[share->indexmap[*dest]]= *dest;
+          switch (ALGORITHM & op)
+          {
+          case DIJKSTRAS:
+            dijkstra_shortest_paths(r, *dest,
+                weight_map(
+                  share->weightmap
+                ).
+                distance_map(
+                    make_iterator_property_map(d.begin(), share->indexmap)
+                ).
+                predecessor_map(
+                    make_iterator_property_map(p.begin(), share->indexmap)
+                ).
+                visitor(
+                    make_dijkstra_visitor(vis)
+                )
+            );
+            break;
+          case BREADTH_FIRST:
+            breadth_first_search(r, *dest,
+                visitor(make_bfs_visitor(
+                    std::make_pair(
+                        record_predecessors(
+                            make_iterator_property_map(p.begin(),
+                                                       share->indexmap),
+                            on_tree_edge()
+                        ),
+                    std::make_pair(
+                        record_distances(
+                            make_iterator_property_map(d.begin(),
+                                                       share->indexmap),
+                            on_tree_edge()
+                        ),
+                        vis
+                    ))
+                ))
+            );
+            break;
+          default:
+            abort();
+          }
+        }
+        break;
+
+      default:
+        break;
+      }
+      return 0;
+    //}
+    //catch (...)
+    //{
+    //  return MISC_FAIL;
+    //}
+  }
+
+  int oqgraph::fetch_row(row& result) throw()
+  {
+    if (!cursor)
+      return NO_MORE_DATA;
+    return cursor->fetch_row(row_info, result);
+  }
+
+  int oqgraph::fetch_row(row& result, const void* ref_ptr) throw()
+  {
+    const reference &ref= *(const reference*) ref_ptr;
+    if (!cursor)
+      return NO_MORE_DATA;
+    return cursor->fetch_row(row_info, result, ref);
+  }
+
+  void oqgraph::row_ref(void *ref_ptr) throw()
+  {
+    reference &ref= *(reference*) ref_ptr;
+    if (cursor)
+      cursor->current(ref);
+    else
+      ref= reference();
+  }
+
+  int oqgraph::random(bool scan) throw()
+  {
+    if (scan || !cursor)
+    {
+      delete cursor; cursor= 0;
+      if (!(cursor= new (std::nothrow) edges_cursor(share)))
+        return MISC_FAIL;
+    }
+    row_info= empty_row;
+    return OK;
+  }
+
+  void oqgraph::free(oqgraph *graph) throw()
+  {
+    delete graph;
+  }
+
+  void oqgraph::free(oqgraph_share *graph) throw()
+  {
+    delete graph;
+  }
+
+  const size_t oqgraph::sizeof_ref= sizeof(reference);
+}
+
+int stack_cursor::fetch_row(const row &row_info, row &result)
+{
+  if (!results.empty())
+  {
+    if (int res= fetch_row(row_info, result, results.top()))
+      return res;
+    results.pop();
+    return oqgraph::OK;
+  }
+  else
+  {
+    last= reference();
+    return oqgraph::NO_MORE_DATA;
+  }
+}
+
+int stack_cursor::fetch_row(const row &row_info, row &result,
+                            const reference &ref)
+{
+  last= ref;
+  if (optional<Vertex> v= last.vertex())
+  {
+    optional<int> seq;
+    optional<EdgeWeight> w;
+    optional<Vertex> v;
+    result= row_info;
+    if ((result.seq_indicator= seq= last.sequence()))
+      result.seq= *seq;
+    if ((result.link_indicator= v= last.vertex()))
+      result.link= share->idmap[*v];
+    if ((result.weight_indicator= w= last.weight()))
+      result.weight= *w;
+    return oqgraph::OK;
+  }
+  else
+    return oqgraph::NO_MORE_DATA;
+}
+
+
+int vertices_cursor::fetch_row(const row &row_info, row &result)
+{
+  vertex_iterator it, end;
+  reference ref;
+  size_t count= position;
+  for (tie(it, end)= vertices(share->g); count && it != end; ++it, --count);
+  if (it != end)
+    ref= reference(position+1, *it);
+  if (int res= fetch_row(row_info, result, ref))
+    return res;
+  position++;
+  return oqgraph::OK;
+}
+
+int vertices_cursor::fetch_row(const row &row_info, row &result,
+                               const reference &ref)
+{
+  last= ref;
+  optional<Vertex> v= last.vertex();
+  result= row_info;
+  if (v)
+  {
+    result.link_indicator= 1;
+    result.link= share->idmap[*v];
+#ifdef DISPLAY_VERTEX_INFO
+    result.seq_indicator= 1;
+    if ((result.seq= degree(*v, share->g)))
+    {
+      EdgeWeight weight= 0;
+      graph_traits<Graph>::in_edge_iterator iei, iei_end;
+      for (tie(iei, iei_end)= in_edges(*v, share->g); iei != iei_end; ++iei)
+        weight+= share->weightmap[*iei];
+      graph_traits<Graph>::out_edge_iterator oei, oei_end;
+      for (tie(oei, oei_end)= out_edges(*v, share->g); oei != oei_end; ++oei)
+        weight+= share->weightmap[*oei];
+      result.weight_indicator= 1;
+      result.weight= weight / result.seq;
+    }
+#endif
+    return oqgraph::OK;
+  }
+  else
+    return oqgraph::NO_MORE_DATA;
+}
+
+int edges_cursor::fetch_row(const row &row_info, row &result)
+{
+  edge_iterator it, end;
+  reference ref;
+  size_t count= position;
+  for (tie(it, end)= edges(share->g); count && it != end; ++it, --count);
+  if (it != end)
+    ref= reference(position+1, *it);
+  if (int res= fetch_row(row_info, result, ref))
+    return res;
+  ++position;
+  return oqgraph::OK;
+}
+
+int edges_cursor::fetch_row(const row &row_info, row &result,
+                            const reference &ref)
+{
+  optional<Edge> edge;
+  if ((edge= (last= ref).edge()))
+  {
+    result= row_info;
+    result.orig_indicator= result.dest_indicator= result.weight_indicator= 1;
+    result.orig= share->idmap[ source( *edge, share->g ) ];
+    result.dest= share->idmap[ target( *edge, share->g ) ];
+    result.weight= share->weightmap[ *edge ];
+    return oqgraph::OK;
+  }
+  return oqgraph::NO_MORE_DATA;
+}
+
+namespace boost {
+  GRAPHCORE_INTERNAL void throw_exception(std::exception const&)
+  {
+    abort();
+  }
+}
Index: mysql-5.0.86/sql/oqgraph/graphcore.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ mysql-5.0.86/sql/oqgraph/graphcore.h	2009-11-03 21:36:59.000000000 -0800
@@ -0,0 +1,116 @@
+/* Copyright (C) 2007-2009 Arjen G Lentz & Antony T Curtis for Open Query
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/* ======================================================================
+   Open Query Graph Computation Engine, based on a concept by Arjen Lentz
+   Mk.II implementation by Antony Curtis & Arjen Lentz
+   For more information, documentation, support, enhancement engineering,
+   and non-GPL licensing, see http://openquery.com/graph
+   or contact graph@openquery.com
+   For packaged binaries, see http://ourdelta.org
+   ======================================================================
+*/
+
+#ifndef oq_graphcore_h_
+#define oq_graphcore_h_
+
+/* #define GRAPHCORE_INTERNAL __attribute__((visibility("hidden"))) */
+#define GRAPHCORE_INTERNAL
+
+#include "graphcore-types.h"
+
+namespace open_query
+{
+  class oqgraph_share;
+  class oqgraph_cursor;
+
+  struct row
+  {
+    bool latch_indicator;
+    bool orig_indicator;
+    bool dest_indicator;
+    bool weight_indicator;
+    bool seq_indicator;
+    bool link_indicator;
+
+    int latch;
+    VertexID orig;
+    VertexID dest;
+    EdgeWeight weight;
+    unsigned seq;
+    VertexID link;
+  };
+
+  class oqgraph
+  {
+    oqgraph_share *const share;
+    oqgraph_cursor *cursor;
+    row row_info;
+
+    inline oqgraph(oqgraph_share*) throw();
+    inline ~oqgraph() throw();
+  public:
+
+    enum error_code
+    {
+      OK= 0,
+      NO_MORE_DATA,
+      EDGE_NOT_FOUND,
+      INVALID_WEIGHT,
+      DUPLICATE_EDGE,
+      CANNOT_ADD_VERTEX,
+      CANNOT_ADD_EDGE,
+      MISC_FAIL
+    };
+
+    struct current_row_st {};
+    static inline current_row_st current_row()
+    { return current_row_st(); }
+
+    unsigned vertices_count() const throw();
+    unsigned edges_count() const throw();
+
+    int delete_all(void) throw();
+
+    int insert_edge(VertexID, VertexID, EdgeWeight, bool=0) throw();
+    int modify_edge(VertexID, VertexID, EdgeWeight) throw();
+    int delete_edge(VertexID, VertexID) throw();
+
+    int modify_edge(current_row_st,
+                    VertexID*, VertexID*, EdgeWeight*, bool=0) throw();
+    int delete_edge(current_row_st) throw();
+
+    int replace_edge(VertexID orig, VertexID dest, EdgeWeight weight) throw()
+    { return insert_edge(orig, dest, weight, true); }
+
+    int search(int*, VertexID*, VertexID*) throw();
+    int random(bool) throw();
+
+    int fetch_row(row&) throw();
+    int fetch_row(row&, const void*) throw();
+    void row_ref(void*) throw();
+
+    static oqgraph* create(oqgraph_share*) throw();
+    static oqgraph_share *create() throw();
+
+    static void free(oqgraph*) throw();
+    static void free(oqgraph_share*) throw();
+
+    static const size_t sizeof_ref;
+  };
+
+}
+#endif
Index: mysql-5.0.86/sql/oqgraph/ha_oqgraph.cc
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ mysql-5.0.86/sql/oqgraph/ha_oqgraph.cc	2009-11-03 21:36:59.000000000 -0800
@@ -0,0 +1,1033 @@
+/* Copyright (C) 2007-2009 Arjen G Lentz & Antony T Curtis for Open Query
+   Portions of this file copyright (C) 2000-2006 MySQL AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/* ======================================================================
+   Open Query Graph Computation Engine, based on a concept by Arjen Lentz
+   Mk.II implementation by Antony Curtis & Arjen Lentz
+   For more information, documentation, support, enhancement engineering,
+   and non-GPL licensing, see http://openquery.com/graph
+   or contact graph@openquery.com
+   For packaged binaries, see http://ourdelta.org
+   ======================================================================
+*/
+
+#ifdef USE_PRAGMA_IMPLEMENTATION
+#pragma implementation				// gcc: Class implementation
+#endif
+
+#define MYSQL_SERVER	// to have THD
+#include "mysql_priv.h"
+#if MYSQL_VERSION_ID >= 50100
+#include <mysql/plugin.h>
+#endif
+
+#ifdef HAVE_OQGRAPH
+
+#include "ha_oqgraph.h"
+#include "graphcore.h"
+
+#define OQGRAPH_STATS_UPDATE_THRESHOLD 10
+
+using namespace open_query;
+
+
+struct oqgraph_info_st
+{
+  THR_LOCK lock;
+  oqgraph_share *graph;
+  uint use_count;
+  uint key_stat_version;
+  uint records;
+  bool dropped;
+  char name[FN_REFLEN+1];
+};
+
+static const char oqgraph_description[]=
+  "Open Query Graph Computation Engine, stored in memory "
+  "(http://openquery.com/graph)";
+
+#if MYSQL_VERSION_ID < 50100
+static bool oqgraph_init();
+
+handlerton oqgraph_hton= {
+  "OQGRAPH",
+  SHOW_OPTION_YES,
+  oqgraph_description,
+  DB_TYPE_OQGRAPH,
+  oqgraph_init,
+  0,       /* slot */
+  0,       /* savepoint size. */
+  NULL,    /* close_connection */
+  NULL,    /* savepoint */
+  NULL,    /* rollback to savepoint */
+  NULL,    /* release savepoint */
+  NULL,    /* commit */
+  NULL,    /* rollback */
+  NULL,    /* prepare */
+  NULL,    /* recover */
+  NULL,    /* commit_by_xid */
+  NULL,    /* rollback_by_xid */
+  NULL,    /* create_cursor_read_view */
+  NULL,    /* set_cursor_read_view */
+  NULL,    /* close_cursor_read_view */
+  HTON_CAN_RECREATE
+};
+
+#define STATISTIC_INCREMENT(X) \
+statistic_increment(table->in_use->status_var.X, &LOCK_status)
+#define MOVE(X) move_field(X)
+#define RECORDS records
+#else
+#define STATISTIC_INCREMENT(X) ha_statistic_increment(&SSV::X)
+#define MOVE(X) move_field_offset(X)
+#define RECORDS stats.records
+#endif
+
+static HASH oqgraph_open_tables;
+static pthread_mutex_t LOCK_oqgraph;
+static bool oqgraph_init_done= 0;
+
+static uchar* get_key(OQGRAPH_INFO *share, uint *length,
+                      my_bool)
+{
+  *length= strlen(share->name);
+  return (uchar*) share->name;
+}
+
+#if MYSQL_VERSION_ID >= 50100
+static handler* oqgraph_create_handler(handlerton *hton, TABLE_SHARE *table,
+                                       MEM_ROOT *mem_root)
+{
+  return new (mem_root) ha_oqgraph(hton, table);
+}
+
+static int oqgraph_init(handlerton *hton)
+{
+#else
+static bool oqgraph_init()
+{
+  if (have_oqgraph == SHOW_OPTION_DISABLED)
+    return 1;
+#endif
+  if (pthread_mutex_init(&LOCK_oqgraph, MY_MUTEX_INIT_FAST))
+    goto error;
+  if (hash_init(&oqgraph_open_tables, &my_charset_bin, 32, 0, 0,
+                (hash_get_key) get_key, 0, 0))
+  {
+    pthread_mutex_destroy(&LOCK_oqgraph);
+    goto error;
+  }
+#if MYSQL_VERSION_ID >= 50100
+  hton->state= SHOW_OPTION_YES;
+  hton->db_type= DB_TYPE_DEFAULT;
+  hton->create= oqgraph_create_handler;
+  hton->flags= HTON_CAN_RECREATE;
+#endif
+  oqgraph_init_done= TRUE;
+  return 0;
+error:
+#if MYSQL_VERSION_ID < 50100
+  have_oqgraph= SHOW_OPTION_DISABLED;
+#endif
+  return 1;
+}
+
+#if MYSQL_VERSION_ID >= 50100
+static int oqgraph_fini(void *)
+{
+  hash_free(&oqgraph_open_tables);
+  pthread_mutex_destroy(&LOCK_oqgraph);
+  oqgraph_init_done= FALSE;
+  return 0;
+}
+#endif
+
+static OQGRAPH_INFO *get_share(const char *name, TABLE *table=0)
+{
+  OQGRAPH_INFO *share;
+  uint length= strlen(name);
+
+  safe_mutex_assert_owner(&LOCK_oqgraph);
+  if (!(share= (OQGRAPH_INFO*) hash_search(&oqgraph_open_tables,
+                                           (byte*) name, length)))
+  {
+    if (!table ||
+        !(share= new OQGRAPH_INFO))
+      return 0;
+    share->use_count= share->key_stat_version= share->records= 0;
+    share->dropped= 0;
+    strmov(share->name, name);
+    if (!(share->graph= oqgraph::create()))
+    {
+      delete share;
+      return 0;
+    }
+    if (my_hash_insert(&oqgraph_open_tables, (byte*) share))
+    {
+      oqgraph::free(share->graph);
+      delete share;
+      return 0;
+    }
+    thr_lock_init(&share->lock);
+  }
+  share->use_count++;
+  return share;
+}
+
+static int free_share(OQGRAPH_INFO *share, bool drop=0)
+{
+  safe_mutex_assert_owner(&LOCK_oqgraph);
+  if (!share)
+    return 0;
+  if (drop)
+  {
+    share->dropped= true;
+    hash_delete(&oqgraph_open_tables, (byte*) share);
+  }
+  if (!--share->use_count)
+  {
+    if (share->dropped)
+    {
+      thr_lock_delete(&share->lock);
+      oqgraph::free(share->graph);
+      delete share;
+    }
+  }
+  return 0;
+}
+
+static int error_code(int res)
+{
+  switch (res)
+  {
+  case oqgraph::OK:
+    return 0;
+  case oqgraph::NO_MORE_DATA:
+    return HA_ERR_END_OF_FILE;
+  case oqgraph::EDGE_NOT_FOUND:
+    return HA_ERR_KEY_NOT_FOUND;
+  case oqgraph::INVALID_WEIGHT:
+    return HA_ERR_AUTOINC_ERANGE;
+  case oqgraph::DUPLICATE_EDGE:
+    return HA_ERR_FOUND_DUPP_KEY;
+  case oqgraph::CANNOT_ADD_VERTEX:
+  case oqgraph::CANNOT_ADD_EDGE:
+    return HA_ERR_RECORD_FILE_FULL;
+  case oqgraph::MISC_FAIL:
+  default:
+    return HA_ERR_CRASHED_ON_USAGE;
+  }
+}
+
+/**
+ * Check if table complies with our designated structure
+ *
+ *    ColName    Type      Attributes
+ *    =======    ========  =============
+ *    latch     SMALLINT  UNSIGNED NULL
+ *    origid    BIGINT    UNSIGNED NULL
+ *    destid    BIGINT    UNSIGNED NULL
+ *    weight    DOUBLE    NULL
+ *    seq       BIGINT    UNSIGNED NULL
+ *    linkid    BIGINT    UNSIGNED NULL
+ *    =================================
+ *
+  CREATE TABLE foo (
+    latch   SMALLINT  UNSIGNED NULL,
+    origid  BIGINT    UNSIGNED NULL,
+    destid  BIGINT    UNSIGNED NULL,
+    weight  DOUBLE    NULL,
+    seq     BIGINT    UNSIGNED NULL,
+    linkid  BIGINT    UNSIGNED NULL,
+    KEY (latch, origid, destid) USING HASH,
+    KEY (latch, destid, origid) USING HASH
+  ) ENGINE=OQGRAPH
+
+ */
+static int oqgraph_check_table_structure (TABLE *table_arg)
+{
+  int i;
+  struct { const char *colname; int coltype; } skel[] = {
+    { "latch" , MYSQL_TYPE_SHORT },
+    { "origid", MYSQL_TYPE_LONGLONG },
+    { "destid", MYSQL_TYPE_LONGLONG },
+    { "weight", MYSQL_TYPE_DOUBLE },
+    { "seq"   , MYSQL_TYPE_LONGLONG },
+    { "linkid", MYSQL_TYPE_LONGLONG },
+  { NULL    , 0}
+  };
+
+  DBUG_ENTER("ha_oqgraph::table_structure_ok");
+
+  Field **field= table_arg->field;
+  for (i= 0; *field && skel[i].colname; i++, field++) {
+    /* Check Column Type */
+    if ((*field)->type() != skel[i].coltype)
+      DBUG_RETURN(-1);
+    if (skel[i].coltype != MYSQL_TYPE_DOUBLE) {
+      /* Check Is UNSIGNED */
+      if (!((*field)->flags & UNSIGNED_FLAG ))
+        DBUG_RETURN(-1);
+    }
+    /* Check THAT  NOT NULL isn't set */
+    if ((*field)->flags & NOT_NULL_FLAG)
+      DBUG_RETURN(-1);
+    /* Check the column name */
+    if (strcmp(skel[i].colname,(*field)->field_name))
+      DBUG_RETURN(-1);
+  }
+
+  if (skel[i].colname || *field || !table_arg->key_info || !table_arg->s->keys)
+    DBUG_RETURN(-1);
+
+  KEY *key= table_arg->key_info;
+  for (uint i= 0; i < table_arg->s->keys; ++i, ++key)
+  {
+    Field **field= table_arg->field;
+    /* check that the first key part is the latch and it is a hash key */
+    if (!(field[0] == key->key_part[0].field &&
+          HA_KEY_ALG_HASH == key->algorithm))
+      DBUG_RETURN(-1);
+    if (key->key_parts == 3)
+    {
+      /* KEY (latch, origid, destid) USING HASH */
+      /* KEY (latch, destid, origid) USING HASH */
+      if (!(field[1] == key->key_part[1].field &&
+            field[2] == key->key_part[2].field) &&
+          !(field[1] == key->key_part[2].field &&
+            field[2] == key->key_part[1].field))
+        DBUG_RETURN(-1);
+    }
+    else
+      DBUG_RETURN(-1);
+  }
+
+  DBUG_RETURN(0);
+}
+
+/*****************************************************************************
+** OQGRAPH tables
+*****************************************************************************/
+
+#if MYSQL_VERSION_ID >= 50100
+ha_oqgraph::ha_oqgraph(handlerton *hton, TABLE_SHARE *table_arg)
+  : handler(hton, table_arg),
+#else
+ha_oqgraph::ha_oqgraph(TABLE *table_arg)
+  : handler(&oqgraph_hton, table_arg),
+#endif
+    share(0), graph(0), records_changed(0), key_stat_version(0)
+{ }
+
+
+static const char *ha_oqgraph_exts[] =
+{
+  NullS
+};
+
+const char **ha_oqgraph::bas_ext() const
+{
+  return ha_oqgraph_exts;
+}
+
+#if MYSQL_VERSION_ID >= 50100
+ulonglong ha_oqgraph::table_flags() const
+#else
+ulong ha_oqgraph::table_flags() const
+#endif
+{
+  return (HA_NO_BLOBS | HA_NULL_IN_KEY |
+          HA_REC_NOT_IN_SEQ | HA_CAN_INSERT_DELAYED);
+}
+
+ulong ha_oqgraph::index_flags(uint inx, uint part, bool all_parts) const
+{
+  return HA_ONLY_WHOLE_INDEX | HA_KEY_SCAN_NOT_ROR;
+}
+
+int ha_oqgraph::open(const char *name, int mode, uint test_if_locked)
+{
+  pthread_mutex_lock(&LOCK_oqgraph);
+  if ((share = get_share(name, table)))
+  {
+    ref_length= oqgraph::sizeof_ref;
+  }
+
+  if (share)
+  {
+    /* Initialize variables for the opened table */
+    thr_lock_data_init(&share->lock, &lock, NULL);
+
+    graph= oqgraph::create(share->graph);
+
+    /*
+      We cannot run update_key_stats() here because we do not have a
+      lock on the table. The 'records' count might just be changed
+      temporarily at this moment and we might get wrong statistics (Bug
+      #10178). Instead we request for update. This will be done in
+      ha_oqgraph::info(), which is always called before key statistics are
+      used.
+    */
+    key_stat_version= share->key_stat_version-1;
+  }
+  pthread_mutex_unlock(&LOCK_oqgraph);
+
+  return (share ? 0 : 1);
+}
+
+int ha_oqgraph::close(void)
+{
+  pthread_mutex_lock(&LOCK_oqgraph);
+  oqgraph::free(graph); graph= 0;
+  int res= free_share(share);
+  pthread_mutex_unlock(&LOCK_oqgraph);
+  return error_code(res);
+}
+
+void ha_oqgraph::update_key_stats()
+{
+  for (uint i= 0; i < table->s->keys; i++)
+  {
+    KEY *key=table->key_info+i;
+    if (!key->rec_per_key)
+      continue;
+    if (key->algorithm != HA_KEY_ALG_BTREE)
+    {
+      if (key->flags & HA_NOSAME)
+        key->rec_per_key[key->key_parts-1]= 1;
+      else
+      {
+        unsigned vertices= graph->vertices_count();
+        unsigned edges= graph->edges_count();
+        uint no_records= vertices ? 2 * (edges + vertices) / vertices : 2;
+        if (no_records < 2)
+          no_records= 2;
+        key->rec_per_key[key->key_parts-1]= no_records;
+      }
+    }
+  }
+  records_changed= 0;
+  /* At the end of update_key_stats() we can proudly claim they are OK. */
+  key_stat_version= share->key_stat_version;
+}
+
+
+int ha_oqgraph::write_row(byte * buf)
+{
+  int res= oqgraph::MISC_FAIL;
+  Field ** const field= table->field;
+  STATISTIC_INCREMENT(ha_write_count);
+
+#if MYSQL_VERSION_ID >= 50100
+  my_bitmap_map *old_map= dbug_tmp_use_all_columns(table, table->read_set);
+#endif
+  my_ptrdiff_t ptrdiff= buf - table->record[0];
+
+  if (ptrdiff)
+  {
+    field[1]->MOVE(ptrdiff);
+    field[2]->MOVE(ptrdiff);
+    field[3]->MOVE(ptrdiff);
+  }
+
+  if (!field[1]->is_null() && !field[2]->is_null())
+  {
+    VertexID orig_id= (VertexID) field[1]->val_int();
+    VertexID dest_id= (VertexID) field[2]->val_int();
+    EdgeWeight weight= 1;
+
+    if (!field[3]->is_null())
+      weight= (EdgeWeight) field[3]->val_real();
+
+    if (!(res= graph->insert_edge(orig_id, dest_id, weight, replace_dups)))
+    {
+      ++records_changed;
+      share->records++;
+    }
+    if (res == oqgraph::DUPLICATE_EDGE && ignore_dups && !insert_dups)
+      res= oqgraph::OK;
+  }
+
+  if (ptrdiff)
+  {
+    field[1]->MOVE(-ptrdiff);
+    field[2]->MOVE(-ptrdiff);
+    field[3]->MOVE(-ptrdiff);
+  }
+#if MYSQL_VERSION_ID >= 50100
+  dbug_tmp_restore_column_map(table->read_set, old_map);
+#endif
+
+  if (!res && records_changed*OQGRAPH_STATS_UPDATE_THRESHOLD > share->records)
+  {
+    /*
+       We can perform this safely since only one writer at the time is
+       allowed on the table.
+    */
+    share->key_stat_version++;
+  }
+
+  return error_code(res);
+}
+
+int ha_oqgraph::update_row(const byte * old, byte * buf)
+{
+  int res= oqgraph::MISC_FAIL;
+  VertexID orig_id, dest_id;
+  EdgeWeight weight= 1;
+  Field **field= table->field;
+  STATISTIC_INCREMENT(ha_update_count);
+
+#if MYSQL_VERSION_ID >= 50100
+  my_bitmap_map *old_map= dbug_tmp_use_all_columns(table, table->read_set);
+#endif
+  my_ptrdiff_t ptrdiff= buf - table->record[0];
+
+  if (ptrdiff)
+  {
+    field[0]->MOVE(ptrdiff);
+    field[1]->MOVE(ptrdiff);
+    field[2]->MOVE(ptrdiff);
+    field[3]->MOVE(ptrdiff);
+  }
+
+  if (inited == INDEX || inited == RND)
+  {
+    VertexID *origp= 0, *destp= 0;
+    EdgeWeight *weightp= 0;
+    if (!field[1]->is_null())
+      *(origp= &orig_id)= (VertexID) field[1]->val_int();
+    if (!field[2]->is_null())
+      *(destp= &dest_id)= (VertexID) field[2]->val_int();
+    if (!field[3]->is_null())
+      *(weightp= &weight)= (EdgeWeight) field[3]->val_real();
+
+    my_ptrdiff_t ptrdiff2= old - buf;
+
+    field[0]->MOVE(ptrdiff2);
+    field[1]->MOVE(ptrdiff2);
+    field[2]->MOVE(ptrdiff2);
+    field[3]->MOVE(ptrdiff2);
+
+    if (field[0]->is_null())
+    {
+      if (!origp == field[1]->is_null() &&
+          *origp == (VertexID) field[1]->val_int())
+        origp= 0;
+      if (!destp == field[2]->is_null() &&
+          *destp == (VertexID) field[2]->val_int())
+        origp= 0;
+      if (!weightp == field[3]->is_null() &&
+          *weightp == (VertexID) field[3]->val_real())
+        weightp= 0;
+
+      if (!(res= graph->modify_edge(oqgraph::current_row(),
+                                    origp, destp, weightp, replace_dups)))
+        ++records_changed;
+      else if (ignore_dups && res == oqgraph::DUPLICATE_EDGE)
+        res= oqgraph::OK;
+    }
+
+    field[0]->MOVE(-ptrdiff2);
+    field[1]->MOVE(-ptrdiff2);
+    field[2]->MOVE(-ptrdiff2);
+    field[3]->MOVE(-ptrdiff2);
+  }
+
+  if (ptrdiff)
+  {
+    field[0]->MOVE(-ptrdiff);
+    field[1]->MOVE(-ptrdiff);
+    field[2]->MOVE(-ptrdiff);
+    field[3]->MOVE(-ptrdiff);
+  }
+#if MYSQL_VERSION_ID >= 50100
+  dbug_tmp_restore_column_map(table->read_set, old_map);
+#endif
+
+  if (!res && records_changed*OQGRAPH_STATS_UPDATE_THRESHOLD > share->records)
+  {
+    /*
+       We can perform this safely since only one writer at the time is
+       allowed on the table.
+    */
+    share->key_stat_version++;
+  }
+  return error_code(res);
+}
+
+int ha_oqgraph::delete_row(const byte * buf)
+{
+  int res= oqgraph::EDGE_NOT_FOUND;
+  Field **field= table->field;
+  STATISTIC_INCREMENT(ha_delete_count);
+
+  if (inited == INDEX || inited == RND)
+  {
+    if ((res= graph->delete_edge(oqgraph::current_row())) == oqgraph::OK)
+    {
+      ++records_changed;
+      share->records--;
+    }
+  }
+  if (res != oqgraph::OK)
+  {
+#if MYSQL_VERSION_ID >= 50100
+    my_bitmap_map *old_map= dbug_tmp_use_all_columns(table, table->read_set);
+#endif
+    my_ptrdiff_t ptrdiff= buf - table->record[0];
+
+    if (ptrdiff)
+    {
+      field[0]->MOVE(ptrdiff);
+      field[1]->MOVE(ptrdiff);
+      field[2]->MOVE(ptrdiff);
+    }
+
+    if (field[0]->is_null() && !field[1]->is_null() && !field[2]->is_null())
+    {
+      VertexID orig_id= (VertexID) field[1]->val_int();
+      VertexID dest_id= (VertexID) field[2]->val_int();
+
+      if ((res= graph->delete_edge(orig_id, dest_id)) == oqgraph::OK)
+      {
+        ++records_changed;
+        share->records--;
+      }
+    }
+
+    if (ptrdiff)
+    {
+      field[0]->MOVE(-ptrdiff);
+      field[1]->MOVE(-ptrdiff);
+      field[2]->MOVE(-ptrdiff);
+    }
+#if MYSQL_VERSION_ID >= 50100
+    dbug_tmp_restore_column_map(table->read_set, old_map);
+#endif
+  }
+
+  if (!res && table->s->tmp_table == NO_TMP_TABLE &&
+      records_changed*OQGRAPH_STATS_UPDATE_THRESHOLD > share->records)
+  {
+    /*
+       We can perform this safely since only one writer at the time is
+       allowed on the table.
+    */
+    share->key_stat_version++;
+  }
+  return error_code(res);
+}
+
+int ha_oqgraph::index_read(byte * buf, const byte * key, uint key_len,
+			enum ha_rkey_function find_flag)
+{
+  DBUG_ASSERT(inited==INDEX);
+  return index_read_idx(buf, active_index, key, key_len, find_flag);
+}
+
+int ha_oqgraph::index_next_same(byte *buf, const byte *key, uint key_len)
+{
+  int res;
+  open_query::row row;
+  DBUG_ASSERT(inited==INDEX);
+  STATISTIC_INCREMENT(ha_read_key_count);
+  if (!(res= graph->fetch_row(row)))
+    res= fill_record(buf, row);
+  table->status= res ? STATUS_NOT_FOUND : 0;
+  return error_code(res);
+}
+
+int ha_oqgraph::index_read_idx(byte * buf, uint index, const byte * key,
+			    uint key_len, enum ha_rkey_function find_flag)
+{
+  Field **field= table->field;
+  KEY *key_info= table->key_info + index;
+  int res;
+  VertexID orig_id, dest_id;
+  int latch;
+  VertexID *orig_idp=0, *dest_idp=0;
+  int *latchp=0;
+  open_query::row row;
+  STATISTIC_INCREMENT(ha_read_key_count);
+
+  bmove_align(buf, table->s->default_values, table->s->reclength);
+  key_restore(buf, (byte*) key, key_info, key_len);
+
+#if MYSQL_VERSION_ID >= 50100
+  my_bitmap_map *old_map= dbug_tmp_use_all_columns(table, table->read_set);
+#endif
+  my_ptrdiff_t ptrdiff= buf - table->record[0];
+
+  if (ptrdiff)
+  {
+    field[0]->MOVE(ptrdiff);
+    field[1]->MOVE(ptrdiff);
+    field[2]->MOVE(ptrdiff);
+  }
+
+  if (!field[0]->is_null())
+  {
+    latch= (int) field[0]->val_int();
+    latchp= &latch;
+  }
+
+  if (!field[1]->is_null())
+  {
+    orig_id= (VertexID) field[1]->val_int();
+    orig_idp= &orig_id;
+  }
+
+  if (!field[2]->is_null())
+  {
+    dest_id= (VertexID) field[2]->val_int();
+    dest_idp= &dest_id;
+  }
+
+  if (ptrdiff)
+  {
+    field[0]->MOVE(-ptrdiff);
+    field[1]->MOVE(-ptrdiff);
+    field[2]->MOVE(-ptrdiff);
+  }
+#if MYSQL_VERSION_ID >= 50100
+  dbug_tmp_restore_column_map(table->read_set, old_map);
+#endif
+
+  res= graph->search(latchp, orig_idp, dest_idp);
+
+  if (!res && !(res= graph->fetch_row(row)))
+    res= fill_record(buf, row);
+  table->status = res ? STATUS_NOT_FOUND : 0;
+  return error_code(res);
+}
+
+int ha_oqgraph::fill_record(byte *record, const open_query::row &row)
+{
+  Field **field= table->field;
+
+  bmove_align(record, table->s->default_values, table->s->reclength);
+
+#if MYSQL_VERSION_ID >= 50100
+  my_bitmap_map *old_map= dbug_tmp_use_all_columns(table, table->write_set);
+#endif
+  my_ptrdiff_t ptrdiff= record - table->record[0];
+
+  if (ptrdiff)
+  {
+    field[0]->MOVE(ptrdiff);
+    field[1]->MOVE(ptrdiff);
+    field[2]->MOVE(ptrdiff);
+    field[3]->MOVE(ptrdiff);
+    field[4]->MOVE(ptrdiff);
+    field[5]->MOVE(ptrdiff);
+  }
+
+  // just each field specifically, no sense iterating
+  if (row.latch_indicator)
+  {
+    field[0]->set_notnull();
+    field[0]->store((longlong) row.latch);
+  }
+
+  if (row.orig_indicator)
+  {
+    field[1]->set_notnull();
+    field[1]->store((longlong) row.orig);
+  }
+
+  if (row.dest_indicator)
+  {
+    field[2]->set_notnull();
+    field[2]->store((longlong) row.dest);
+  }
+
+  if (row.weight_indicator)
+  {
+    field[3]->set_notnull();
+    field[3]->store((double) row.weight);
+  }
+
+  if (row.seq_indicator)
+  {
+    field[4]->set_notnull();
+    field[4]->store((longlong) row.seq);
+  }
+
+  if (row.link_indicator)
+  {
+    field[5]->set_notnull();
+    field[5]->store((longlong) row.link);
+  }
+
+  if (ptrdiff)
+  {
+    field[0]->MOVE(-ptrdiff);
+    field[1]->MOVE(-ptrdiff);
+    field[2]->MOVE(-ptrdiff);
+    field[3]->MOVE(-ptrdiff);
+    field[4]->MOVE(-ptrdiff);
+    field[5]->MOVE(-ptrdiff);
+  }
+#if MYSQL_VERSION_ID >= 50100
+  dbug_tmp_restore_column_map(table->write_set, old_map);
+#endif
+
+  return 0;
+}
+
+int ha_oqgraph::rnd_init(bool scan)
+{
+  return error_code(graph->random(scan));
+}
+
+int ha_oqgraph::rnd_next(byte *buf)
+{
+  int res;
+  open_query::row row;
+  STATISTIC_INCREMENT(ha_read_rnd_next_count);
+  if (!(res= graph->fetch_row(row)))
+    res= fill_record(buf, row);
+  table->status= res ? STATUS_NOT_FOUND: 0;
+  return error_code(res);
+}
+
+int ha_oqgraph::rnd_pos(byte * buf, byte *pos)
+{
+  int res;
+  open_query::row row;
+  STATISTIC_INCREMENT(ha_read_rnd_count);
+  if (!(res= graph->fetch_row(row, pos)))
+    res= fill_record(buf, row);
+  table->status=res ? STATUS_NOT_FOUND: 0;
+  return error_code(res);
+}
+
+void ha_oqgraph::position(const byte *record)
+{
+  graph->row_ref((void*) ref);	// Ref is aligned
+}
+
+int ha_oqgraph::cmp_ref(const byte *ref1, const byte *ref2)
+{
+  return memcmp(ref1, ref2, oqgraph::sizeof_ref);
+}
+
+int ha_oqgraph::info(uint flag)
+{
+  RECORDS= graph->vertices_count() + graph->edges_count();
+#if 0
+  records= hp_info.records;
+  deleted= hp_info.deleted;
+  errkey=  hp_info.errkey;
+  mean_rec_length= hp_info.reclength;
+  data_file_length= hp_info.data_length;
+  index_file_length= hp_info.index_length;
+  max_data_file_length= hp_info.max_records* hp_info.reclength;
+  delete_length= hp_info.deleted * hp_info.reclength;
+#endif
+  /*
+    If info() is called for the first time after open(), we will still
+    have to update the key statistics. Hoping that a table lock is now
+    in place.
+  */
+  if (key_stat_version != share->key_stat_version)
+    update_key_stats();
+  return 0;
+}
+
+int ha_oqgraph::extra(enum ha_extra_function operation)
+{
+  switch (operation)
+  {
+  case HA_EXTRA_IGNORE_DUP_KEY:
+    ignore_dups= true;
+    break;
+  case HA_EXTRA_NO_IGNORE_DUP_KEY:
+    ignore_dups= false;
+    insert_dups= false;
+    break;
+  case HA_EXTRA_WRITE_CAN_REPLACE:
+    replace_dups= true;
+    break;
+  case HA_EXTRA_WRITE_CANNOT_REPLACE:
+    replace_dups= false;
+    break;
+  case HA_EXTRA_INSERT_WITH_UPDATE:
+    insert_dups= true;
+    break;
+  default:
+    break;
+  }
+  return 0;
+}
+
+int ha_oqgraph::delete_all_rows()
+{
+  int res;
+  if (!(res= graph->delete_all()))
+  {
+    share->records= 0;
+  }
+
+  if (!res && table->s->tmp_table == NO_TMP_TABLE)
+  {
+    /*
+       We can perform this safely since only one writer at the time is
+       allowed on the table.
+    */
+    share->key_stat_version++;
+  }
+  return error_code(res);
+}
+
+int ha_oqgraph::external_lock(THD *thd, int lock_type)
+{
+  return 0;					// No external locking
+}
+
+
+THR_LOCK_DATA **ha_oqgraph::store_lock(THD *thd,
+				       THR_LOCK_DATA **to,
+				       enum thr_lock_type lock_type)
+{
+  if (lock_type != TL_IGNORE && lock.type == TL_UNLOCK)
+    lock.type=lock_type;
+  *to++= &lock;
+  return to;
+}
+
+/*
+  We have to ignore ENOENT entries as the HEAP table is created on open and
+  not when doing a CREATE on the table.
+*/
+
+int ha_oqgraph::delete_table(const char *name)
+{
+  int res= 0;
+  OQGRAPH_INFO *share;
+  pthread_mutex_lock(&LOCK_oqgraph);
+  if ((share= get_share(name)))
+  {
+    res= free_share(share, true);
+  }
+  pthread_mutex_unlock(&LOCK_oqgraph);
+  return error_code(res);
+}
+
+int ha_oqgraph::rename_table(const char * from, const char * to)
+{
+  pthread_mutex_lock(&LOCK_oqgraph);
+  if (OQGRAPH_INFO *share= get_share(from))
+  {
+    strmov(share->name, to);
+    hash_update(&oqgraph_open_tables, (byte*) share,
+                (byte*) from, strlen(from));
+  }
+  pthread_mutex_unlock(&LOCK_oqgraph);
+  return 0;
+}
+
+
+ha_rows ha_oqgraph::records_in_range(uint inx, key_range *min_key,
+                                  key_range *max_key)
+{
+  KEY *key=table->key_info+inx;
+  //if (key->algorithm == HA_KEY_ALG_BTREE)
+  //  return btree_records_in_range(file, inx, min_key, max_key);
+
+  if (!min_key || !max_key ||
+      min_key->length != max_key->length ||
+      min_key->length < key->key_length - key->key_part[2].store_length ||
+      min_key->flag != HA_READ_KEY_EXACT ||
+      max_key->flag != HA_READ_AFTER_KEY)
+  {
+    if (min_key->length == key->key_part[0].store_length)
+    {
+      // If latch is not null and equals 0, return # nodes
+      DBUG_ASSERT(key->key_part[0].store_length == 3);
+      if (key->key_part[0].null_bit && !min_key->key[0] &&
+          !min_key->key[1] && !min_key->key[2])
+        return graph->vertices_count();
+    }
+    return HA_POS_ERROR;			// Can only use exact keys
+  }
+
+  if (RECORDS <= 1)
+    return RECORDS;
+
+  /* Assert that info() did run. We need current statistics here. */
+  DBUG_ASSERT(key_stat_version == share->key_stat_version);
+  ha_rows result= key->rec_per_key[key->key_parts-1];
+
+  return result;
+}
+
+
+int ha_oqgraph::create(const char *name, TABLE *table_arg,
+		    HA_CREATE_INFO *create_info)
+{
+  int res = -1;
+  OQGRAPH_INFO *share;
+
+  pthread_mutex_lock(&LOCK_oqgraph);
+  if ((share= get_share(name)))
+  {
+    free_share(share);
+  }
+  else
+  {
+    if (!oqgraph_check_table_structure(table_arg))
+      res= 0;;
+  }
+  pthread_mutex_unlock(&LOCK_oqgraph);
+
+  if (this->share)
+    info(HA_STATUS_NO_LOCK | HA_STATUS_CONST | HA_STATUS_VARIABLE);
+  return error_code(res);
+}
+
+
+void ha_oqgraph::update_create_info(HA_CREATE_INFO *create_info)
+{
+  table->file->info(HA_STATUS_AUTO);
+  //if (!(create_info->used_fields & HA_CREATE_USED_AUTO))
+  //  create_info->auto_increment_value= auto_increment_value;
+}
+
+#if MYSQL_VERSION_ID >= 50100
+struct st_mysql_storage_engine oqgraph_storage_engine=
+{ MYSQL_HANDLERTON_INTERFACE_VERSION };
+
+mysql_declare_plugin(oqgraph)
+{
+  MYSQL_STORAGE_ENGINE_PLUGIN,
+  &oqgraph_storage_engine,
+  "OQGRAPH",
+  "Arjen Lentz & Antony T Curtis, Open Query",
+  oqgraph_description,
+  PLUGIN_LICENSE_GPL,
+  (int (*)(void*)) oqgraph_init, /* Plugin Init                  */
+  oqgraph_fini,               /* Plugin Deinit                   */
+  0x0200,                     /* Version: 2.0                    */
+  NULL,                       /* status variables                */
+  NULL,                       /* system variables                */
+  NULL                        /* config options                  */
+}
+mysql_declare_plugin_end;
+#endif
+
+#endif
Index: mysql-5.0.86/sql/oqgraph/ha_oqgraph.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ mysql-5.0.86/sql/oqgraph/ha_oqgraph.h	2009-11-03 21:36:59.000000000 -0800
@@ -0,0 +1,114 @@
+/* Copyright (C) 2007-2009 Arjen G Lentz & Antony T Curtis for Open Query
+   Portions of this file copyright (C) 2000-2006 MySQL AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/* ======================================================================
+   Open Query Graph Computation Engine, based on a concept by Arjen Lentz
+   Mk.II implementation by Antony Curtis & Arjen Lentz
+   For more information, documentation, support, enhancement engineering,
+   and non-GPL licensing, see http://openquery.com/graph
+   or contact graph@openquery.com
+   For packaged binaries, see http://ourdelta.org
+   ======================================================================
+*/
+
+#ifdef USE_PRAGMA_INTERFACE
+#pragma interface			/* gcc class implementation */
+#endif
+
+
+typedef struct oqgraph_info_st OQGRAPH_INFO;
+
+#if MYSQL_VERSION_ID >= 50120
+typedef uchar byte;
+#endif
+
+namespace open_query
+{
+  struct row;
+  class oqgraph;
+}
+
+/* class for the the Open Query Graph handler */
+
+class ha_oqgraph: public handler
+{
+  OQGRAPH_INFO *share;
+  open_query::oqgraph *graph;
+  THR_LOCK_DATA lock;
+  /* number of records changed since last statistics update */
+  uint records_changed;
+  uint key_stat_version;
+  bool replace_dups, ignore_dups, insert_dups;
+
+  int fill_record(byte*, const open_query::row&);
+
+public:
+#if MYSQL_VERSION_ID >= 50100
+  ha_oqgraph(handlerton *hton, TABLE_SHARE *table);
+  ulonglong table_flags() const;
+#else
+  ha_oqgraph(TABLE *table);
+  ulong table_flags() const;
+#endif
+  ~ha_oqgraph() {}
+  const char *table_type() const
+  {
+    return "OQGRAPH";
+  }
+  const char *index_type(uint inx)
+  {
+    return "HASH";
+  }
+  /* Rows also use a fixed-size format */
+  enum row_type get_row_type() const { return ROW_TYPE_FIXED; }
+  const char **bas_ext() const;
+  ulong index_flags(uint inx, uint part, bool all_parts) const;
+  uint max_supported_keys()          const { return MAX_KEY; }
+  uint max_supported_key_part_length() const { return MAX_KEY_LENGTH; }
+  double scan_time() { return (double) 1000000000; }
+  double read_time(uint index, uint ranges, ha_rows rows)
+  { return 1; }
+
+  int open(const char *name, int mode, uint test_if_locked);
+  int close(void);
+  int write_row(byte * buf);
+  int update_row(const byte * old_data, byte * new_data);
+  int delete_row(const byte * buf);
+  int index_read(byte * buf, const byte * key,
+		 uint key_len, enum ha_rkey_function find_flag);
+  int index_read_idx(byte * buf, uint idx, const byte * key,
+		     uint key_len, enum ha_rkey_function find_flag);
+  int index_next_same(byte * buf, const byte * key, uint key_len);
+  int rnd_init(bool scan);
+  int rnd_next(byte *buf);
+  int rnd_pos(byte * buf, byte *pos);
+  void position(const byte *record);
+  int info(uint);
+  int extra(enum ha_extra_function operation);
+  int external_lock(THD *thd, int lock_type);
+  int delete_all_rows(void);
+  ha_rows records_in_range(uint inx, key_range *min_key, key_range *max_key);
+  int delete_table(const char *from);
+  int rename_table(const char * from, const char * to);
+  int create(const char *name, TABLE *form, HA_CREATE_INFO *create_info);
+  void update_create_info(HA_CREATE_INFO *create_info);
+
+  THR_LOCK_DATA **store_lock(THD *thd, THR_LOCK_DATA **to,
+			     enum thr_lock_type lock_type);
+  int cmp_ref(const byte *ref1, const byte *ref2);
+private:
+  void update_key_stats();
+};
